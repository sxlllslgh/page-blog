<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++将PCM音频写入WAV文件的极简处理</title>
    <link href="/zh-CN/cpp-write-wav/"/>
    <url>/zh-CN/cpp-write-wav/</url>
    
    <content type="html"><![CDATA[<p>出于项目需要，要记录音频流到文件。音频流的获取是Windows音频会话API（Windows Audio Session API，WASAPI）的标准写法，最开始实验的时候是将PCM直接二进制写入文件，再用Python引SciPy库转为WAV，但这显然在大批量样本下显得很笨拙，所以就研究了一下WAV的文件格式，琢磨出来以下极简写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// WASAPI的头文件和用法自行查询，这是节选代码</span><br><br><span class="hljs-comment">// 头文件变量定义节选，项目用到的是C++/WinRT，所以用了大量的com指针，但能用标准指针的地方我都尽量用了标准指针</span><br><span class="hljs-type">int</span> audioDeviceID = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> audioCaptureRefreshFrequency = <span class="hljs-number">10000000</span>;<br>winrt::com_ptr&lt;IMMDeviceEnumerator&gt; pEnumerator&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>winrt::com_ptr&lt;IMMDeviceCollection&gt; pDeviceCollection&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>winrt::com_ptr&lt;IMMDevice&gt; pDevice&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>WAVEFORMATEX* pwfx&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>winrt::com_ptr&lt;IAudioCaptureClient&gt; pCaptureClient&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>winrt::com_ptr&lt;IAudioClient&gt; pAudioClient&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>UINT32 packetLength = <span class="hljs-number">0</span>;<br>std::unique_ptr&lt;std::fstream&gt; audioWriter;<br><span class="hljs-type">uint32_t</span> audioSize = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-comment">// 函数实现节选</span><br>REFERENCE_TIME hnsRequestedDuration = audioCaptureRefreshFrequency;<br>UINT32 bufferFrameCount;<br>REFERENCE_TIME hnsActualDuration;<br>UINT32 numFramesAvailable;<br>BYTE* pData&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>DWORD flags;<br><br><span class="hljs-built_in">CoCreateInstance</span>(__uuidof(MMDeviceEnumerator), <span class="hljs-literal">nullptr</span>, CLSCTX_INPROC_SERVER, __uuidof(IMMDeviceEnumerator), pEnumerator.<span class="hljs-built_in">put_void</span>());<br>pEnumerator-&gt;<span class="hljs-built_in">EnumAudioEndpoints</span>(eCapture, DEVICE_STATE_ACTIVE, pDeviceCollection.<span class="hljs-built_in">put</span>());<br>pDeviceCollection-&gt;<span class="hljs-built_in">Item</span>(audioDeviceID, pDevice.<span class="hljs-built_in">put</span>());<br>pDevice-&gt;<span class="hljs-built_in">Activate</span>(__uuidof(IAudioClient), CLSCTX_ALL, <span class="hljs-literal">nullptr</span>, pAudioClient.<span class="hljs-built_in">put_void</span>());<br>pAudioClient-&gt;<span class="hljs-built_in">GetMixFormat</span>(&amp;pwfx);<br>pAudioClient-&gt;<span class="hljs-built_in">Initialize</span>(AUDCLNT_SHAREMODE_SHARED, <span class="hljs-number">0</span>, hnsRequestedDuration, <span class="hljs-number">0</span>, pwfx, <span class="hljs-literal">nullptr</span>);<br>pAudioClient-&gt;<span class="hljs-built_in">GetBufferSize</span>(&amp;bufferFrameCount);<br>pAudioClient-&gt;<span class="hljs-built_in">GetService</span>(__uuidof(IAudioCaptureClient), pCaptureClient.<span class="hljs-built_in">put_void</span>());<br><br>hnsActualDuration = (<span class="hljs-type">double</span>)audioCaptureRefreshFrequency * bufferFrameCount / pwfx-&gt;nSamplesPerSec;<br>pAudioClient-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-comment">// 创建WAV音频文件</span><br>audioWriter = std::<span class="hljs-built_in">make_unique</span>&lt;std::fstream&gt;(std::filesystem::<span class="hljs-built_in">path</span>(<span class="hljs-string">L&quot;audio.wav&quot;</span>).<span class="hljs-built_in">string</span>(), std::ios::trunc | std::ios::out | std::ios::binary);<br><span class="hljs-comment">// 音频数据大小初始化（字节）</span><br>audioSize = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 写入WAV文件头，这里44个字节的文件头有着明确的含义，请参考WAV具体文件定义格式，除了两个涉及音频数据大小的4字节整型，其他部分都是固定的（这里用到的是16bit位深、16KHz采样率、单通道，WAV格式定义非常简单清楚，如果要改音频流格式，修改对应位置16进制数即可）</span><br>audioWriter-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\x52\x49\x46\x46\x00\x00\x00\x00\x57\x41\x56\x45\x66\x6D\x74\x20\x10\x00\x00\x00\x01\x00\x01\x00\x80\x3E\x00\x00\x00\x7D\x00\x00\x02\x00\x10\x00\x64\x61\x74\x61\x00\x00\x00\x00&quot;</span>, <span class="hljs-number">44</span>);<br><br><span class="hljs-keyword">while</span> (isAudioCaptureEnabled &amp;&amp; pCaptureClient != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FAILED</span>(pCaptureClient-&gt;<span class="hljs-built_in">GetNextPacketSize</span>(&amp;packetLength))) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    pcmNew.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">while</span> (packetLength != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FAILED</span>(pCaptureClient-&gt;<span class="hljs-built_in">GetBuffer</span>(&amp;pData, &amp;numFramesAvailable, &amp;flags, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>))) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (flags &amp; AUDCLNT_BUFFERFLAGS_SILENT) &#123;<br>            pData = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        <span class="hljs-type">float</span> resamplingSum = <span class="hljs-number">0.0f</span>;<br>        <span class="hljs-type">int</span> resamplingCounter = pwfx-&gt;nSamplesPerSec / <span class="hljs-number">16000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, c = <span class="hljs-number">1</span>; i &lt; numFramesAvailable * pwfx-&gt;nBlockAlign; i += pwfx-&gt;nBlockAlign, c++) &#123;<br>            <span class="hljs-built_in">memcpy</span>(&amp;tempAudioFrame, &amp;(pData[i]), <span class="hljs-built_in">sizeof</span>(tempAudioFrame));<br>            resamplingSum += tempAudioFrame;<br>            <span class="hljs-keyword">if</span> (c % resamplingCounter == <span class="hljs-number">0</span>) &#123;<br>                pcmNew.<span class="hljs-built_in">push_back</span>((<span class="hljs-type">int16_t</span>)(resamplingSum / (<span class="hljs-type">float</span>)resamplingCounter * <span class="hljs-number">32767.0f</span>));<br>                resamplingSum = <span class="hljs-number">0.0f</span>;<br>            &#125;<br>        &#125;<br>        <br>        winrt::<span class="hljs-built_in">check_hresult</span>(pCaptureClient-&gt;<span class="hljs-built_in">ReleaseBuffer</span>(numFramesAvailable));<br>        winrt::<span class="hljs-built_in">check_hresult</span>(pCaptureClient-&gt;<span class="hljs-built_in">GetNextPacketSize</span>(&amp;packetLength));<br>    &#125;<br>    <span class="hljs-comment">// 写入本次Buffer中的音频格式</span><br>    audioWriter-&gt;<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)pcmNew.<span class="hljs-built_in">data</span>(), pcmNew.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(pcmNew[<span class="hljs-number">0</span>]));<br>    <span class="hljs-comment">// 累加本次音频数据大小</span><br>    audioSize += pcmNew.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(pcmNew[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">// 睡眠一半buffer长度后，开启下次循环</span><br>    <span class="hljs-built_in">Sleep</span>(hnsActualDuration / audioCaptureRefreshFrequency * <span class="hljs-number">40</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，关闭音频写入流的时候，需要根据最终的音频大小修改文件头指定位置的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (audioWriter != <span class="hljs-literal">nullptr</span>) &#123;<br>    audioWriter-&gt;<span class="hljs-built_in">seekp</span>(<span class="hljs-number">4</span>);<br>    audioWriter-&gt;<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)(&amp;audioSize), <span class="hljs-number">4</span>);<br>    audioWriter-&gt;<span class="hljs-built_in">seekp</span>(<span class="hljs-number">0x28</span>);<br>    <span class="hljs-keyword">auto</span> fileSize = audioSize + <span class="hljs-number">36</span>;<br>    audioWriter-&gt;<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)(&amp;fileSize), <span class="hljs-number">4</span>);<br>    audioWriter-&gt;<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，一个超级简单的方法就将PCM音频流写成了播放器能够直接打开的WAV格式音频文件。</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>音频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORCID Record Action Usage</title>
    <link href="/en-US/orcid-record-action-en-US/"/>
    <url>/en-US/orcid-record-action-en-US/</url>
    
    <content type="html"><![CDATA[<h1 id="ORCID-Record-Action"><a href="#ORCID-Record-Action" class="headerlink" title="ORCID Record Action"></a>ORCID Record Action</h1><p>I developed a GitHub action to automatically fetch record, including personal information, publications, authors, etc. The action page is available at <a href="https://github.com/marketplace/actions/orcid-record-action">GitHub Action Marketplace</a>, and here is the manual.</p><h2 id="ORCID-API-Configurations"><a href="#ORCID-API-Configurations" class="headerlink" title="ORCID API Configurations"></a>ORCID API Configurations</h2><h3 id="1-Register-your-personal-public-API-client"><a href="#1-Register-your-personal-public-API-client" class="headerlink" title="1. Register your personal public API client"></a>1. Register your personal public API client</h3><p>Log in your ORCID account and visit the <a href="https://orcid.org/developer-tools">developer tools</a> page, create your personal public API client. Detailed steps please refer the <a href="https://info.orcid.org/documentation/features/public-api">offical document</a>. You can fill in application information and redirect URIs as you like, it has no effect on the subsequent steps.</p><p>Please remember your <strong>Client ID</strong> and <strong>Client secret</strong>.</p><h3 id="2-Get-your-access-token"><a href="#2-Get-your-access-token" class="headerlink" title="2. Get your access token"></a>2. Get your access token</h3><p>In command line, use your <strong>Client ID</strong> and <strong>Client secret</strong> to get your <strong>access token</strong>. It should have a very long expiration time (about 20 years):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;Accept: application/json&quot;</span> -H <span class="hljs-string">&quot;Content-Type: application/x-www-form-urlencoded&quot;</span> --data-urlencode<br> <span class="hljs-string">&quot;client_id=CLIENT_ID&quot;</span> --data-urlencode <span class="hljs-string">&quot;client_secret=CLIENT_SECRET&quot;</span> --data-urlencode<br> <span class="hljs-string">&quot;scope=/read-public&quot;</span> --data-urlencode <span class="hljs-string">&quot;grant_type=client_credentials&quot;</span> https://orcid.org/oauth/token<br></code></pre></td></tr></table></figure><p>Then you may get a response in JSON format:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">631138518</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/read-public&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;orcid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>Please remember the <strong>access_token</strong>.</p><h2 id="Inputs"><a href="#Inputs" class="headerlink" title="Inputs"></a>Inputs</h2><h3 id="orcid-id"><a href="#orcid-id" class="headerlink" title="orcid-id"></a><code>orcid-id</code></h3><p><strong>Required</strong> The ORCID ID of researcher.</p><h3 id="access-token"><a href="#access-token" class="headerlink" title="access-token"></a><code>access-token</code></h3><p><strong>Required</strong> The ORCID access token obtained above.</p><h3 id="record-file"><a href="#record-file" class="headerlink" title="record-file"></a><code>record-file</code></h3><p><strong>Optional</strong> The record json file to write. If this input was given, the output <code>record</code> will not be generated.</p><h2 id="Outputs"><a href="#Outputs" class="headerlink" title="Outputs"></a>Outputs</h2><h3 id="record"><a href="#record" class="headerlink" title="record"></a><code>record</code></h3><p>The record string in JSON format. This output only exists when the <code>record-file</code> input is not given.</p><h2 id="Example-usage"><a href="#Example-usage" class="headerlink" title="Example usage"></a>Example usage</h2><h3 id="1-Optional-Save-your-access-token-and-other-variables-in-GitHub"><a href="#1-Optional-Save-your-access-token-and-other-variables-in-GitHub" class="headerlink" title="1. (Optional) Save your access token and other variables in GitHub"></a>1. (Optional) Save your access token and other variables in GitHub</h3><p>Create a new <strong>repository secret</strong> in <a href="https://github.com/USERNAME/REPOSITORY/settings/secrets/actions">https://github.com/USERNAME/REPOSITORY/settings/secrets/actions</a>, create a new repository secret to store your <strong>access_token</strong> obtained above. Here we name it <strong>ORCID_ACCESS_TOKEN</strong>.</p><p>Further, in this page, switch to the <strong>Variables</strong> tab, create follow variables for your workflow:</p><table><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Example</th></tr></thead><tbody><tr><td align="center">ORCID_ID</td><td align="center">Your ORCID id.</td><td align="center">XXXX-XXXX-XXXX-XXXX</td></tr><tr><td align="center">ORCID_ACCESS_TOKEN</td><td align="center">The ORCID public api access token.</td><td align="center">xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</td></tr><tr><td align="center">RECORD_FILE</td><td align="center">The related path of the works file in your repository.</td><td align="center">assets&#x2F;record.json</td></tr></tbody></table><h3 id="2-Create-an-action-to-auto-update-your-ORCID-record"><a href="#2-Create-an-action-to-auto-update-your-ORCID-record" class="headerlink" title="2. Create an action to auto update your ORCID record."></a>2. Create an action to auto update your ORCID record.</h3><p>The workflow’s code is as follows:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Update</span> <span class="hljs-string">Record</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># Create a scheduled task, in this example we run it at the first day of every month.</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 1 * *&quot;</span><br>  <span class="hljs-comment"># Enable manually executing.</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br>  <br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>    <br>    <span class="hljs-comment"># Fetch record with orcid id and access token</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">record</span> <span class="hljs-string">with</span> <span class="hljs-string">token</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">sxlllslgh/orcid-record-action@v1</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">record</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">orcid-id:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.ORCID_ID</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">access-token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ORCID_ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">record-file:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Make</span> <span class="hljs-string">sure</span> <span class="hljs-string">the</span> <span class="hljs-string">record</span> <span class="hljs-string">file</span> <span class="hljs-string">is</span> <span class="hljs-string">tracked</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-comment"># If record file changed, return exit code 1, otherwise 0.</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Judge</span> <span class="hljs-string">if</span> <span class="hljs-string">file</span> <span class="hljs-string">changed</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">changed</span><br>      <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">--exit-code</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Judge</span> <span class="hljs-string">if</span> <span class="hljs-string">staged</span> <span class="hljs-string">file</span> <span class="hljs-string">changed</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">cached</span><br>      <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">--exit-code</span> <span class="hljs-string">--cached</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Update</span> <span class="hljs-string">record</span><br>      <span class="hljs-attr">if:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">steps.changed.outcome</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;failure&#x27;</span> <span class="hljs-string">||</span> <span class="hljs-string">steps.cached.outcome</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;failure&#x27;</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          git config --global user.name &#x27;$&#123;&#123; vars.GIT_USERNAME &#125;&#125;&#x27;</span><br><span class="hljs-string">          git config --global user.email &#x27;$&#123;&#123; vars.GIT_EMAIL &#125;&#125;&#x27;</span><br><span class="hljs-string">          git commit -am &quot;Automatically update record.&quot;</span><br><span class="hljs-string">          git push</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI</tag>
      
      <tag>Frontend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用GitHub Action自动抓取ORCID记录</title>
    <link href="/zh-CN/orcid-record-action/"/>
    <url>/zh-CN/orcid-record-action/</url>
    
    <content type="html"><![CDATA[<h1 id="ORCID-Record-GitHub-Action"><a href="#ORCID-Record-GitHub-Action" class="headerlink" title="ORCID Record GitHub Action"></a>ORCID Record GitHub Action</h1><p>我做了一个GitHub Action，利用ORCID的公共API自动抓取研究人员的记录，包括其发表、作者、期刊和时间等等。因为原始API这些信息是位于不同URI下的，因此我进行了整合以写入到一个单独的JSON文件中。这个Action目前可以在<a href="https://github.com/marketplace/actions/orcid-record-action">GitHub Action市场</a>中安装，用法如下。</p><h2 id="ORCID-API配置"><a href="#ORCID-API配置" class="headerlink" title="ORCID API配置"></a>ORCID API配置</h2><h3 id="1-注册你的个人公共API客户端"><a href="#1-注册你的个人公共API客户端" class="headerlink" title="1. 注册你的个人公共API客户端"></a>1. 注册你的个人公共API客户端</h3><p>首先登录你的ORCID账号，进入<a href="https://orcid.org/developer-tools">developer tools</a>页面创建你的个人API客户端。详细的步骤请参考<a href="https://info.orcid.org/documentation/features/public-api">官方文档</a>。应用信息和重定向地址可以随便填。</p><p>记住你的 <strong>Client ID</strong> 和 __Client secret__。</p><h3 id="2-获取你的访问令牌"><a href="#2-获取你的访问令牌" class="headerlink" title="2. 获取你的访问令牌"></a>2. 获取你的访问令牌</h3><p>在命令行中，用你的 <strong>Client ID</strong> 和 <strong>Client secret</strong> 来获取你的 __访问令牌__。官方目前默认给20年的超长有效期，因此获取这个令牌的命令只需要执行一次，我没有写到Action中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;Accept: application/json&quot;</span> -H <span class="hljs-string">&quot;Content-Type: application/x-www-form-urlencoded&quot;</span> --data-urlencode<br> <span class="hljs-string">&quot;client_id=CLIENT_ID&quot;</span> --data-urlencode <span class="hljs-string">&quot;client_secret=CLIENT_SECRET&quot;</span> --data-urlencode<br> <span class="hljs-string">&quot;scope=/read-public&quot;</span> --data-urlencode <span class="hljs-string">&quot;grant_type=client_credentials&quot;</span> https://orcid.org/oauth/token<br></code></pre></td></tr></table></figure><p>然后你就可以得到一个JSON格式的响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">631138518</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/read-public&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;orcid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这里<strong>access_toke</strong>就是要记住的<strong>访问令牌</strong>。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="orcid-id"><a href="#orcid-id" class="headerlink" title="orcid-id"></a><code>orcid-id</code></h3><p><strong>必须</strong> 研究人员的ORCID ID。</p><h3 id="access-token"><a href="#access-token" class="headerlink" title="access-token"></a><code>access-token</code></h3><p><strong>必须</strong> 上面获取到的<strong>访问令牌</strong>。</p><h3 id="record-file"><a href="#record-file" class="headerlink" title="record-file"></a><code>record-file</code></h3><p><strong>可选</strong> 要写入结果的JSON文件地址（相对于仓库根目录）。如果这个输入给了，<code>record</code>输出就不会有。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="record"><a href="#record" class="headerlink" title="record"></a><code>record</code></h3><p>JSON格式的记录字符串。这个输出只有在<code>record-file</code>输入没有的时候才会产生。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-（可选）在GitHub中保存你的访问令牌和变量"><a href="#1-（可选）在GitHub中保存你的访问令牌和变量" class="headerlink" title="1. （可选）在GitHub中保存你的访问令牌和变量"></a>1. （可选）在GitHub中保存你的访问令牌和变量</h3><p>在 <a href="https://github.com/USERNAME/REPOSITORY/settings/secrets/actions">https://github.com/USERNAME/REPOSITORY/settings/secrets/actions</a> 中创建新的仓库级别密钥（Secret）来保存你的访问令牌，这里我们将其命名为<strong>ORCID_ACCESS_TOKEN</strong>。</p><p>然后还是这个页面，切到<strong>Variables</strong>选项卡，创建以下的变量：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">ORCID_ID</td><td align="center">研究人员的ORCID ID</td><td align="center">XXXX-XXXX-XXXX-XXXX</td></tr><tr><td align="center">ORCID_ACCESS_TOKEN</td><td align="center">你的ORCID API访问令牌</td><td align="center">xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</td></tr><tr><td align="center">RECORD_FILE</td><td align="center">要写入记录的JSON文件路径（可选，相对于仓库根目录）</td><td align="center">assets&#x2F;record.json</td></tr></tbody></table><h3 id="2-创建一个Action来自动更新ORCID记录"><a href="#2-创建一个Action来自动更新ORCID记录" class="headerlink" title="2. 创建一个Action来自动更新ORCID记录"></a>2. 创建一个Action来自动更新ORCID记录</h3><p>示例工作流代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Update</span> <span class="hljs-string">Record</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># 创建一个定期循环任务，这里我们设置为每月1号0点0分</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 1 * *&quot;</span><br>  <span class="hljs-comment"># 允许手动执行工作流</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br>  <br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>    <br>    <span class="hljs-comment"># 使用ORCID ID和访问令牌抓取ORCID记录</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">record</span> <span class="hljs-string">with</span> <span class="hljs-string">token</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">sxlllslgh/orcid-record-action@v1</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">record</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">orcid-id:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.ORCID_ID</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">access-token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ORCID_ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">record-file:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Make</span> <span class="hljs-string">sure</span> <span class="hljs-string">the</span> <span class="hljs-string">record</span> <span class="hljs-string">file</span> <span class="hljs-string">is</span> <span class="hljs-string">tracked</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-comment"># 如果记录文件有变化，返回退出代码1，否则返回0</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Judge</span> <span class="hljs-string">if</span> <span class="hljs-string">file</span> <span class="hljs-string">changed</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">changed</span><br>      <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">--exit-code</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Judge</span> <span class="hljs-string">if</span> <span class="hljs-string">staged</span> <span class="hljs-string">file</span> <span class="hljs-string">changed</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">cached</span><br>      <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">--exit-code</span> <span class="hljs-string">--cached</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">vars.RECORD_FILE</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Update</span> <span class="hljs-string">record</span><br>      <span class="hljs-attr">if:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">steps.changed.outcome</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;failure&#x27;</span> <span class="hljs-string">||</span> <span class="hljs-string">steps.cached.outcome</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;failure&#x27;</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          git config --global user.name &#x27;$&#123;&#123; vars.GIT_USERNAME &#125;&#125;&#x27;</span><br><span class="hljs-string">          git config --global user.email &#x27;$&#123;&#123; vars.GIT_EMAIL &#125;&#125;&#x27;</span><br><span class="hljs-string">          git commit -am &quot;Automatically update record.&quot;</span><br><span class="hljs-string">          git push</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续集成</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWRT使用mwan3实现单线多拨并整合WLAN转有线</title>
    <link href="/zh-CN/openwrt-mwan3-sta/"/>
    <url>/zh-CN/openwrt-mwan3-sta/</url>
    
    <content type="html"><![CDATA[<p>书接<a href="https://sxlllslgh.github.io/2022/09/26/openwrt-ipv6-nat">上文</a>，本文介绍一下新版OpenWRT上的单线多拨。其中，“单线（多个虚拟网卡）”用macvlan实现，“多拨”则用mwan3实现。此外因为我的网络的特殊情况（有线网稳定但很慢，无线网比较快但容易掉线），因此我还附加了将无线网转到有线网的操作，即WLAN的客户端模式。整个网络的拓扑图大致如下：</p><pre><code class=" mermaid">graph TD    A[Wire WAN] --&gt;|macvlan| B(Virtual WAN 1)    A --&gt; |macvlan| C(Virtual WAN 2)    B --&gt; E(Router)    C --&gt; E(Router)    D[Wireless WAN] --&gt; E    E --&gt;|NAT| F[LAN]</code></pre><h1 id="单线多拨"><a href="#单线多拨" class="headerlink" title="单线多拨"></a>单线多拨</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>包的安装没什么好说的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">opkg update<br>opkg install macvlan mwan3<br></code></pre></td></tr></table></figure><blockquote><p>截至我写这篇文章时，mwan3仍旧没有对新版防火墙做支持，因此他会默认安装旧版的iptables，因此<a href="https://sxlllslgh.github.io/2022/09/26/openwrt-ipv6-nat">上文</a>绕开旧版防火墙的折腾目前是没有意义的，但将来总会适配的。</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h1 id="虚拟网卡和网络接口"><a href="#虚拟网卡和网络接口" class="headerlink" title="虚拟网卡和网络接口"></a>虚拟网卡和网络接口</h1><p>这里先做个双拨，再网上叠加都照猫画虎就行。首先修改<code>/etc/config/network</code>，添加以下内容，用于添加虚拟网卡：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs conf">config device<br>option type &#x27;macvlan&#x27;<br>option ifname &#x27;eth1&#x27;<br>option mode &#x27;vepa&#x27;<br>option name &#x27;vth0&#x27;<br>option macaddr &#x27;自定义的MAC地址1&#x27;<br><br>config device<br>option type &#x27;macvlan&#x27;<br>option ifname &#x27;eth1&#x27;<br>option mode &#x27;vepa&#x27;<br>option name &#x27;vth1&#x27;<br>option macaddr &#x27;自定义的MAC地址2&#x27;<br></code></pre></td></tr></table></figure><p>注意自定义的MAC地址不能和物理网卡一样，否则会出问题。</p><p>然后再添加网络接口，每个接口和虚拟网卡一一对应，仍然是修改<code>/etc/config/network</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs conf">config interface &#x27;wan&#x27;<br>option device &#x27;vth0&#x27;<br>option proto &#x27;pppoe&#x27;<br>option username &#x27;拨号用户名&#x27;<br>option password &#x27;拨号密码&#x27;<br>option ipv6 &#x27;auto&#x27;<br>option metric &#x27;1&#x27;<br><br>config interface &#x27;wan6&#x27;<br>option device &#x27;vth0&#x27;<br>option proto &#x27;dhcpv6&#x27;<br>option metric &#x27;1&#x27;<br><br>config interface &#x27;wanb&#x27;<br>option device &#x27;vth1&#x27;<br>option proto &#x27;pppoe&#x27;<br>option username &#x27;拨号用户名&#x27;<br>option password &#x27;拨号密码&#x27;<br>option ipv6 &#x27;auto&#x27;<br>option metric &#x27;2&#x27;<br><br>config interface &#x27;wanb6&#x27;<br>option device &#x27;vth1&#x27;<br>option proto &#x27;dhcpv6&#x27;<br>option metric &#x27;2&#x27;<br></code></pre></td></tr></table></figure><p>几个注意事项：</p><ol><li>后面跟个6的表示是IPv6接口。</li><li>对于每组接口（IPv4一个和IPv6一个），都应该对应不同的虚拟网卡。</li><li>每个协议下的接口都应具有不同的距离度量（metric）。即比如这里的IPv4接口wan和wanb，两个metric就必须不一样。但组内不同协议的接口则没必要一样，比如wan和wan6，两个metric我图方便都写了1，其实可以不一样。</li><li>即便拨号后，每个wan接口会衍生出自己的IPv6虚拟接口，也不要删除这里定义的接口。</li></ol><h2 id="mwan3多拨"><a href="#mwan3多拨" class="headerlink" title="mwan3多拨"></a>mwan3多拨</h2><p>这里修改完后，再去修改mwan3的设置<code>/etc/config/mwan3</code>，这里只列出一组接口的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 这里的IPv4接口名称对应之前/etc/config/network里的接口名称<br>config interface &#x27;wan&#x27;<br>option enabled &#x27;1&#x27;<br>option family &#x27;ipv4&#x27;<br>option initial_state &#x27;online&#x27;<br>list track_ip &#x27;www.baidu.com&#x27;<br>option track_method &#x27;ping&#x27;<br>option count &#x27;1&#x27;<br>option size &#x27;56&#x27;<br>option max_ttl &#x27;60&#x27;<br>option timeout &#x27;4&#x27;<br>option interval &#x27;10&#x27;<br>option failure_interval &#x27;5&#x27;<br>option recovery_interval &#x27;5&#x27;<br>option down &#x27;5&#x27;<br>option reliability &#x27;1&#x27;<br>option up &#x27;1&#x27;<br><br># 这里的IPv6接口对应拨号后DHCPv6获取的虚拟接口名称，一般就是IPv4接口名称后面加个底杠“_”再跟个“6”<br>config interface &#x27;wan_6&#x27;<br>option family &#x27;ipv6&#x27;<br>option enabled &#x27;1&#x27;<br>option initial_state &#x27;online&#x27;<br>option track_method &#x27;ping&#x27;<br>option count &#x27;1&#x27;<br>option size &#x27;56&#x27;<br>option max_ttl &#x27;60&#x27;<br>option timeout &#x27;4&#x27;<br>option interval &#x27;10&#x27;<br>option failure_interval &#x27;5&#x27;<br>option recovery_interval &#x27;5&#x27;<br>option down &#x27;5&#x27;<br>option reliability &#x27;1&#x27;<br>option up &#x27;1&#x27;<br>    # 这里的追踪地址建议写一个IPv6网站的IP地址，用域名的话有时候解析会有问题导致本来网通着但检测失败下线了<br>list track_ip &#x27;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx&#x27;<br></code></pre></td></tr></table></figure><p>其他接口配置照着写就可以，这里仍然以两组接口为例（wan&#x2F;wan_6和wanb&#x2F;wanb_6），则需要依次配置每个接口的权重和距离、默认路由规则和负载均衡策略，修改<code>/etc/config/mwan3</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 先配置每个接口的权重和距离<br>config member &#x27;wan_m1_w1&#x27;<br>option interface &#x27;wan&#x27;<br>    # 默认距离度量为1，如需修改可以在这里改，仍然是IPv4和IPv6各自考虑<br>option metric &#x27;2&#x27;<br>    # 默认权重为1，如需修改可以在这里改<br>    option weight &#x27;2&#x27;<br><br>config member &#x27;wan6_m1_w1&#x27;<br>option interface &#x27;wan_6&#x27;<br><br>config member &#x27;wanb_m1_w1&#x27;<br>option interface &#x27;wanb&#x27;<br><br>config member &#x27;wanb6_m1_w1&#x27;<br>option interface &#x27;wanb_6&#x27;<br><br># 默认路由规则<br>config rule &#x27;default_rule_v4&#x27;<br>option dest_ip &#x27;0.0.0.0/0&#x27;<br>option family &#x27;ipv4&#x27;<br>option use_policy &#x27;balanced&#x27;<br><br>config rule &#x27;default_rule_v6&#x27;<br>option dest_ip &#x27;::/0&#x27;<br>option family &#x27;ipv6&#x27;<br>option use_policy &#x27;balanced&#x27;<br><br># 负载均衡策略<br>config policy &#x27;balanced&#x27;<br>list use_member &#x27;wan_m1_w1&#x27;<br>list use_member &#x27;wanb_m1_w1&#x27;<br>list use_member &#x27;wan6_m1_w1&#x27;<br>list use_member &#x27;wanb6_m1_w1&#x27;<br>option last_resort &#x27;default&#x27;<br></code></pre></td></tr></table></figure><p>其余配置一般保持默认即可。</p><h2 id="mwan3特殊配置"><a href="#mwan3特殊配置" class="headerlink" title="mwan3特殊配置"></a>mwan3特殊配置</h2><p>mwan3有个常用的附加配置，就是固定流量的接口。比如HTTPS协议的流量，必须哪儿出哪儿进，因此固定HTTPS协议的443端口TCP流量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs conf">config rule &#x27;https&#x27;<br>option sticky &#x27;1&#x27;<br>option dest_port &#x27;443&#x27;<br>option proto &#x27;tcp&#x27;<br>option use_policy &#x27;balanced&#x27;<br></code></pre></td></tr></table></figure><h1 id="无线网转有线网"><a href="#无线网转有线网" class="headerlink" title="无线网转有线网"></a>无线网转有线网</h1><p>接下来就是将无线网转到有线网，即开启无线网的客户端模式，修改<code>/etc/config/wireless</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf">config wifi-iface &#x27;default_radio1&#x27;<br>option device &#x27;radio1&#x27;<br>option encryption &#x27;none&#x27;<br>option mode &#x27;sta&#x27;<br>option ssid &#x27;你要连接的WLAN名称&#x27;<br>option bssid &#x27;你要连接的WLAN热点MAC地址&#x27;<br>option ifname &#x27;wwan&#x27;<br>option network &#x27;wwan&#x27;<br>option macaddr &#x27;可以虚拟一个MAC地址用于某些需要绑定或认证的场景&#x27;<br></code></pre></td></tr></table></figure><p>上述配置新加了一个名为<code>wwan</code>的网络，需要修改<code>/etc/config/firewall</code>将其加入WAN防火墙组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs conf">config zone<br>option name &#x27;wan&#x27;<br>list network &#x27;wan&#x27;<br>list network &#x27;wan6&#x27;<br>list network &#x27;wan_6&#x27;<br>list network &#x27;wanb&#x27;<br>list network &#x27;wanb6&#x27;<br>list network &#x27;wanb_6&#x27;<br>list network &#x27;wwan&#x27;<br>option input &#x27;REJECT&#x27;<br>option output &#x27;ACCEPT&#x27;<br>option forward &#x27;REJECT&#x27;<br>option masq &#x27;1&#x27;<br>option mtu_fix &#x27;1&#x27;<br></code></pre></td></tr></table></figure><p>如此一来，就可以连接上WLAN了。接下来修改<code>/etc/config/mwan3</code>将其加入多拨：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs conf">config interface &#x27;wwan&#x27;<br>option enabled &#x27;1&#x27;<br>option family &#x27;ipv4&#x27;<br>    # 照抄有线网的IPv4配置即可<br><br>config member &#x27;wwan_m1_w1&#x27;<br>option interface &#x27;wwan&#x27;<br><br># 在负载均衡策略里添加wwan网络<br>config policy &#x27;balanced&#x27;<br>list use_member &#x27;wwan_m1_w1&#x27;<br>list use_member &#x27;wan_m1_w1&#x27;<br>list use_member &#x27;wanb_m1_w1&#x27;<br>list use_member &#x27;wan6_m1_w1&#x27;<br>list use_member &#x27;wanb6_m1_w1&#x27;<br>option last_resort &#x27;default&#x27;<br></code></pre></td></tr></table></figure><h2 id="固定流量网络接口"><a href="#固定流量网络接口" class="headerlink" title="固定流量网络接口"></a>固定流量网络接口</h2><p>开头说过，我的网络下，有线网稳定但慢，无线网快但不稳，因此，对于需要稳定连接但速度要求不高的流量，比如SSH，我想把他固定在有线网上，于是继续修改<code>/etc/config/mwan3</code>，添加一组仅走有线网的策略，并将SSH流量绑定到这个策略上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">config policy &#x27;wire_only&#x27;<br>list use_member &#x27;wan_m1_w1&#x27;<br>list use_member &#x27;wan6_m1_w1&#x27;<br>list use_member &#x27;wanb_m1_w1&#x27;<br>list use_member &#x27;wanb6_m1_w1&#x27;<br>option last_resort &#x27;unreachable&#x27;<br><br>config rule &#x27;SSH&#x27;<br>option proto &#x27;tcp&#x27;<br>option dest_port &#x27;22&#x27;<br>option sticky &#x27;1&#x27;<br>option use_policy &#x27;wire_only&#x27;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，一个实现了单线多拨+整合无线网的负载均衡就实现了。我这里测速没有提升（即便是开多线程，不确定是不是HTTPS固定的问题），但迅雷是实打实所有接口都跑满了，肥肠奈斯。</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>OpenWRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWRT使用nftables实现IPv6 NAT</title>
    <link href="/zh-CN/openwrt-ipv6-nat/"/>
    <url>/zh-CN/openwrt-ipv6-nat/</url>
    
    <content type="html"><![CDATA[<p>手贱给路由器升级到了OpenWRT 22.03，结果防火墙规则文件<code>/etc/firewall.user</code>直接没了，好家伙。一查才发现新版OpenWRT用上了Firewall 4，规则管理工具从iptables升级到了nftables，貌似天然对IPv6支持，不再需要手动安装ip6tables，嗯是个好东西，用起来。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>校园网总是能给你整点儿意想不到的烂活出来，比如给你分配一个&#x2F;128的IPv6地址，又或者在DHCPv6协商阶段给你返一个错误报文。前者直接违背了IPv6的初衷，导致大多数低端路由器下的设备直接拿不到IPv6地址；后者不确定是配置问题还是华为那个核心路由器（型号好像是NE80）的bug，在客户端向服务器发送Advertise报文后直接返回一个错误报文，然后又成功返回一个地址，中间这个错误报文直接导致了MikroTik的RouterOS系统判断获取失败重启协商过程从而一直拿不到地址。</p><h1 id="旧版OpenWRT的解决办法"><a href="#旧版OpenWRT的解决办法" class="headerlink" title="旧版OpenWRT的解决办法"></a>旧版OpenWRT的解决办法</h1><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>在之前的OpenWRT中，我用了一个清华大佬的贴子中的NAT办法，首先安装一堆IPv6相关的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">opkg update<br>opkg install ip6tables kmod-ipt-nat6 kmod-ip6tables kmod-ip6tables-extra<br></code></pre></td></tr></table></figure><p>然后在自定义防火墙文件<code>/etc/firewall.user</code>中添加自定义规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip6tables -t nat -A POSTROUTING -o pppoe-wan -j MASQUERADE<br>ip6tables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT<br>ip6tables -A FORWARD -i br-lan -j ACCEPT<br></code></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>此外，OpenWRT从DHCP服务器拿到地址后，会自动添加一条路由：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">default from 2001:xxxx:xxxx:xxxx::/64 via fe80::xxxx dev pppoe-wan metric 512<br></code></pre></td></tr></table></figure><p>这条路由对路由器下的设备没有用，因此，需要在<code>/etc/hotplug.d/iface</code>文件夹下新加一条接口热插拔规则，姑且起名为<code>99-ipv6</code>（前面的数字表示执行顺序，后面的名字随便起）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>[ &quot;$ACTION&quot; = ifup ] || exit 0<br>iface=wan6 # 这个接口名称对应/etc/config/network中定义的IPv6接口<br>[ -z &quot;$iface&quot; -o &quot;$INTERFACE&quot; = &quot;$iface&quot; ] || exit 0<br>ip -6 route add default via fe80::xxxx dev pppoe-wan metric 1<br></code></pre></td></tr></table></figure><p>比较稳妥的办法就像上面这样，记住默认路由中的DHCP服务器地址，然后添加一条metric比较小的默认路由。</p><blockquote><p>清华大佬用了sed替换上面那条默认路由，但我的网络中获取IPv6地址有延迟，导致一开始没有默认路由，于是就失败了。此外，第二条删除默认路的代码也有问题，语法有错。附上清华大佬的默认路由替换脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>[ &quot;$ACTION&quot; = ifup ] || exit 0<br>iface=wan6<br>[ -z &quot;$iface&quot; -o &quot;$INTERFACE&quot; = &quot;$iface&quot; ] || exit 0<br>ip -6 route add `ip -6 route show default | sed -e &#x27;s/from [^ ]* //&#x27;| sed -e &#x27;s/metric [0-9]*/metric 1/&#x27;`<br>ip -6 route del `ip -6 route show default | grep from`<br></code></pre></td></tr></table></figure></blockquote><p>到这里应该内网就能上IPv6了。</p><h1 id="新版OpenWRT的解决办法"><a href="#新版OpenWRT的解决办法" class="headerlink" title="新版OpenWRT的解决办法"></a>新版OpenWRT的解决办法</h1><h2 id="新防火墙"><a href="#新防火墙" class="headerlink" title="新防火墙"></a>新防火墙</h2><p>新版的防火墙规则大改，研究了半天后终于搞好了。路由的热插拔脚本仍然有，但不需要装一堆IPv6的包了，只需要在<code>/etc/config/firewall</code>中添加一条NAT规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs conf">config nat<br>option name &#x27;IPv6 Masquerade&#x27;<br>option family &#x27;ipv6&#x27;<br>option src &#x27;wan&#x27;<br>option target &#x27;MASQUERADE&#x27;<br>list proto &#x27;all&#x27;<br></code></pre></td></tr></table></figure><p>这条规则对应之前自定义防火墙规则的第一条，用于开启伪装。</p><p>另外两条我没有找到OpenWRT的uci实现的办法，只能修改<code>/etc/nftables.d/10-custom-filter-chains.nft</code>文件。这个本质上就是nftables版的<code>/etc/firewall.user</code>，只是语法有了很大变化。只需要修改一个post_forward链即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">chain user_post_forward &#123;<br>    ct state established,related accept # 对应上面第二条conntrack规则<br>    iifname br-lan accept # 对应上面第三条规则<br>&#125;<br></code></pre></td></tr></table></figure><p>至此三条自定义防火墙规则升级完成，不再需要ip6tables了。</p><h1 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h1><p>有些网络，可能需要单独设置DHCPv6相关的设置，比如路由通告（RA）等，以我的网络为例，需要修改<code>/etc/config/dhcp</code>里面lan相关的设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">config dhcp &#x27;lan&#x27;<br>option interface &#x27;lan&#x27;<br>option start &#x27;100&#x27;<br>option limit &#x27;150&#x27;<br>option leasetime &#x27;12h&#x27;<br>option dhcpv4 &#x27;server&#x27;<br>option dhcpv6 &#x27;server&#x27;<br># 主要就是下面这三条<br>option ra &#x27;server&#x27;<br>option ra_default &#x27;1&#x27;<br>option ra_management &#x27;2&#x27;<br></code></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实新版OpenWRT中仍然保留了对Firewall 3的兼容性，<code>firewall.user</code>规则仍然可以用，但多拨的mwan3貌似和此有冲突（只是貌似，也不确定是不是mwan3自己对Firewall 4兼容有问题），因此我先把防火墙改上来，有空再解决多拨的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>OpenWRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拥抱Hexo</title>
    <link href="/zh-CN/hello-hexo/"/>
    <url>/zh-CN/hello-hexo/</url>
    
    <content type="html"><![CDATA[<p>我总是说话的巨人，行动的矮子。从八年前大二第一次接触前端开始，就一直想做一个自己的博客网站，幻想着做成拥有注册、登录、评论……等等诸多功能齐全的一个大项目，方案也从一开始的裸PHP，一直追新到Laravel、Ruby on Rails、Spring、Springboot + Angular……结果我拿这些工具接了不少活，自己的站却一直处于新建文件夹状态，属实讽刺。</p><p>之前想着要不就CSDN算了，反正写博客也是给人看的嘛。但最近CSDN的表现过于令人失望，无休止的广告、会员和禁止复制——天下代码一大抄，你不让我复制我看的个🔨。我的技术分享自然是希望复制的人越多越好，所以最终还是下定决心转移到Hexo上，静态就静态吧，反正也没什么人气，没有评论的必要。之前的博客我会逐步转移到这边来，这样也才有一种自己的东西自己掌控的感觉，而不是泡在一个充斥着利益恶臭的泥潭里。</p><p>不过我也低估了Hexo的配置难度，有手生的原因（最后一次碰npm还是六年前写的那个Laravel插件），主要精力也花费在了GitHub的Action的配置上，花了大半天才搞好。CI&#x2F;CD是个好东西，可惜门槛也确实有一点，以后还是要多熟悉，毕竟长期搞一个项目，自动部署不要太舒服。</p><p>写论文去了，再写不出来要被老板锤死了。</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
